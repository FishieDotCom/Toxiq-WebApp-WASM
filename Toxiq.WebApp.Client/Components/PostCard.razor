@* Toxiq.WebApp.Client/Components/PostCard.razor *@
@using Microsoft.FluentUI.AspNetCore.Components
@using Toxiq.Mobile.Dto
@using Toxiq.WebApp.Client.Services.Feed
@inject NavigationManager Navigation
@inject IJSRuntime JSRuntime
@inject IFeedService FeedService

<div class="post-card @GetPostTypeClass()" @onclick="HandlePostClick">
    <div class="post-content">
        <!-- Header -->
        <div class="post-header">
            <div class="post-author" @onclick="HandleProfileClick" @onclick:stopPropagation="true">
                <span class="author-name">@Post.Name</span>
                <span class="author-username">@@@Post.UserName</span>
            </div>
            @if (Post.Type == PostType.Burn)
            {
                <div class="burn-indicator">🔥🔥</div>
            }
        </div>

        <!-- Main Content -->
        <div class="post-text" style="@GetContentStyle()">
            <FormattedText Text="@Post.Content" />
        </div>

        <!-- Media (Images) -->
        @if (Post.PostMedia?.Count > 0)
        {
            <div class="post-media">
                <img src="@Post.PostMedia[0].MediaPath" 
                     alt="Post attachment" 
                     class="post-image" />
            </div>
        }

        <!-- Reply Content (if this is a reply) -->
        @if (Post.ReplyType != ReplyType.Non && ReplyPost != null)
        {
            <div class="reply-content">
                <div class="reply-header">
                    <span class="reply-author-name">@ReplyPost.Name</span>
                    <span class="reply-author-username">@@@ReplyPost.UserName</span>
                </div>
                <p class="reply-text">@ReplyPost.Content</p>
                @if (ReplyPost.PostMedia?.Count > 0)
                {
                    <img src="@ReplyPost.PostMedia[0].MediaPath" 
                         alt="Reply attachment" 
                         class="reply-image" />
                }
            </div>
        }

        <!-- Stats Row -->
        <div class="post-stats">
            <span class="stat-item">@GetSupportCountDisplay() Likes</span>
            <span class="stat-item">@(Post.CommentCount ?? 0) Comments</span>
        </div>

        <!-- Action Buttons -->
        <div class="post-actions">
            <!-- Support Buttons (Upvote/Downvote) -->
            <div class="support-buttons">
                <button class="action-btn support-btn @GetSupportClass(true)"
                        @onclick="HandleUpvote" 
                        @onclick:stopPropagation="true"
                        disabled="@IsProcessingVote">
                    <div class="btn-icon">
                        @if (CurrentSupportStatus == true)
                        {
                            <svg width="18" height="18" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M15.057 9.004c.46-1.427.693-2.676.693-3.753 0-2.399-.939-4.248-2.5-4.248-.847 0-1.109.505-1.437 1.747.017-.065-.163.634-.215.821-.101.36-.277.97-.527 1.831a.247.247 0 0 1-.03.065L8.175 9.953A5.885 5.885 0 0 1 5.32 12.28l-1.257.481a1.75 1.75 0 0 0-1.092 1.968l.686 3.538a2.25 2.25 0 0 0 1.673 1.757l8.25 2.022a4.75 4.75 0 0 0 5.733-3.44l1.574-6.173a2.75 2.75 0 0 0-2.665-3.429h-3.165Z" />
                            </svg>
                        }
                        else
                        {
                            <svg width="18" height="18" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M16.5 5.202c0-2.442-1.14-4.199-3.007-4.199-1.026 0-1.378.602-1.746 2-.075.289-.112.43-.151.568-.101.359-.277.97-.527 1.831a.25.25 0 0 1-.03.065L8.174 9.953a5.885 5.885 0 0 1-2.855 2.326l-.473.181a2.75 2.75 0 0 0-1.716 3.092l.404 2.086a3.25 3.25 0 0 0 2.417 2.538l7.628 1.87a4.75 4.75 0 0 0 5.733-3.40l1.415-5.55a3.25 3.25 0 0 0-3.15-4.052h-1.822c.496-1.633.746-2.893.746-3.802Z" />
                            </svg>
                        }
                    </div>
                </button>

                <button class="action-btn support-btn @GetSupportClass(false)"
                        @onclick="HandleDownvote" 
                        @onclick:stopPropagation="true"
                        disabled="@IsProcessingVote">
                    <div class="btn-icon">
                        @if (CurrentSupportStatus == false)
                        {
                            <svg width="18" height="18" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M15.057 14.183c.46 1.427.693 2.676.693 3.753 0 2.399-.939 4.248-2.5 4.248-.8 0-1.078-.45-1.383-1.547l-.27-1.021c-.1-.359-.276-.97-.526-1.831a.246.246 0 0 0-.03-.065l-2.866-4.486a5.886 5.886 0 0 0-2.855-2.327l-1.257-.48A1.75 1.75 0 0 1 2.97 8.458l.686-3.539A2.25 2.25 0 0 1 5.33 3.163l8.25-2.022a4.75 4.75 0 0 1 5.733 3.44l1.574 6.173a2.75 2.75 0 0 1-2.665 3.429h-3.165Z" />
                            </svg>
                        }
                        else
                        {
                            <svg width="18" height="18" fill="currentColor" viewBox="0 0 24 24">
                                <path d="M16.5 17.985c0 2.442-1.14 4.198-3.007 4.198-.975 0-1.341-.542-1.69-1.795l-.207-.772c-.101-.359-.277-.97-.527-1.831a.249.249 0 0 0-.03-.065l-2.866-4.486a5.886 5.886 0 0 0-2.855-2.327l-.473-.18A2.75 2.75 0 0 1 3.13 7.634l.404-2.087A3.25 3.25 0 0 1 5.95 3.011l7.628-1.87a4.75 4.75 0 0 1 5.733 3.44l1.415 5.55a3.25 3.25 0 0 1-3.15 4.052h-1.822c.496 1.633.746 2.893.746 3.802Z" />
                            </svg>
                        }
                    </div>
                </button>
            </div>

            <!-- Comment Button -->
            <button class="action-btn comment-btn"
                    @onclick="HandleCommentClick" 
                    @onclick:stopPropagation="true">
                <div class="btn-icon">
                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Comment())" />
                </div>
                <span class="btn-text">Comment</span>
            </button>

            <!-- Share Button -->
            <button class="action-btn share-btn"
                    @onclick="HandleShare" 
                    @onclick:stopPropagation="true">
                <div class="btn-icon">
                    <FluentIcon Value="@(new Microsoft.FluentUI.AspNetCore.Components.Icons.Regular.Size20.Share())" />
                </div>
                <span class="btn-text">Share</span>
            </button>
        </div>
    </div>
</div>

@code {
    [Parameter] public BasePost Post { get; set; } = default!;
    [Parameter] public bool FullPost { get; set; } = false;
    [Parameter] public EventCallback<BasePost> OnPostClick { get; set; }

    private BasePost? ReplyPost { get; set; }
    private bool? CurrentSupportStatus { get; set; }
    private int? CurrentSupportCount { get; set; }
    private bool IsProcessingVote { get; set; } = false;

    protected override async Task OnInitializedAsync()
    {
        // Initialize support status and count (matching mobile app pattern)
        CurrentSupportStatus = Post.SupportStatus;
        CurrentSupportCount = Post.SupportCount;

        // Load reply post if this is a reply (matching mobile app behavior)
        if (Post.ReplyType != ReplyType.Non && Post.ReplyRefId.HasValue)
        {
            try
            {
                // Note: You'll need to implement GetPost in the API service
                // ReplyPost = await ApiService.PostService.GetPost(Post.ReplyRefId.Value);
            }
            catch (Exception)
            {
                // Handle error silently (matching mobile app pattern)
            }
        }

        // Subscribe to feed service events for real-time updates
        FeedService.PostInteractionChanged += OnPostInteractionChanged;
    }

    public void Dispose()
    {
        FeedService.PostInteractionChanged -= OnPostInteractionChanged;
    }

    private void OnPostInteractionChanged(object? sender, PostInteractionEventArgs e)
    {
        if (e.PostId == Post.Id)
        {
            CurrentSupportStatus = e.NewSupportStatus;
            if (e.NewSupportCount.HasValue)
            {
                CurrentSupportCount = e.NewSupportCount.Value;
            }
            StateHasChanged();
        }
    }

    private string GetPostTypeClass()
    {
        //return Post.Type == PostType.Burn ? "post-card burn-post" : 
        return "post-card";
    }

    private string GetContentStyle()
    {
        var maxHeight = FullPost ? "none" : "200px";
        var overflow = FullPost ? "visible" : "hidden";
        return $"max-height: {maxHeight}; overflow: {overflow};";
    }

    private string GetSupportClass(bool isUpvote)
    {
        if (CurrentSupportStatus == isUpvote)
        {
            return isUpvote ? "active-up" : "active-down";
        }
        return "";
    }

    private int GetSupportCountDisplay()
    {
        return CurrentSupportCount ?? Post.SupportCount ?? 0;
    }

    private async Task HandleUpvote()
    {
        if (IsProcessingVote) return;

        IsProcessingVote = true;
        try
        {
            bool success;

            // Toggle logic matching mobile app behavior
            if (CurrentSupportStatus == true)
            {
                // Remove vote if already upvoted (mobile app uses Deletevote)
                success = await FeedService.RemoveVoteAsync(Post.Id);
                if (success)
                {
                    CurrentSupportStatus = null;
                    CurrentSupportCount = Math.Max(0, (CurrentSupportCount ?? 0) - 1);
                }
            }
            else
            {
                // Upvote the post
                success = await FeedService.UpvotePostAsync(Post.Id);
                if (success)
                {
                    // Adjust count based on previous state
                    var countAdjustment = CurrentSupportStatus == false ? 2 : 1;
                    CurrentSupportStatus = true;
                    CurrentSupportCount = (CurrentSupportCount ?? 0) + countAdjustment;
                }
            }

            if (success)
            {
                StateHasChanged();
            }
        }
        catch (Exception)
        {
            // Handle error silently (matching mobile app pattern)
        }
        finally
        {
            IsProcessingVote = false;
        }
    }

    private async Task HandleDownvote()
    {
        if (IsProcessingVote) return;

        IsProcessingVote = true;
        try
        {
            bool success;

            // Toggle logic matching mobile app behavior
            if (CurrentSupportStatus == false)
            {
                // Remove vote if already downvoted
                success = await FeedService.RemoveVoteAsync(Post.Id);
                if (success)
                {
                    CurrentSupportStatus = null;
                    CurrentSupportCount = (CurrentSupportCount ?? 0) + 1;
                }
            }
            else
            {
                // Downvote the post
                success = await FeedService.DownvotePostAsync(Post.Id);
                if (success)
                {
                    // Adjust count based on previous state
                    var countAdjustment = CurrentSupportStatus == true ? 2 : 1;
                    CurrentSupportStatus = false;
                    CurrentSupportCount = Math.Max(0, (CurrentSupportCount ?? 0) - countAdjustment);
                }
            }

            if (success)
            {
                StateHasChanged();
            }
        }
        catch (Exception)
        {
            // Handle error silently (matching mobile app pattern)
        }
        finally
        {
            IsProcessingVote = false;
        }
    }

    private async Task HandlePostClick()
    {
        if (OnPostClick.HasDelegate)
        {
            await OnPostClick.InvokeAsync(Post);
        }
        else
        {
            Navigation.NavigateTo($"/post/{Post.Id}");
        }
    }

    private async Task HandleCommentClick()
    {
        Navigation.NavigateTo($"/post/{Post.Id}#comments");
    }

    private async Task HandleProfileClick()
    {
        Navigation.NavigateTo($"/profile/{Post.UserName}");
    }

    private async Task HandleShare()
    {
        try
        {
            var postUrl = $"{Navigation.BaseUri}post/{Post.Id}";
            var shareText = Post.Content?.Length > 100 
                ? Post.Content.Substring(0, 100) + "..." 
                : Post.Content;

            // Try native Web Share API first
            await JSRuntime.InvokeVoidAsync("navigator.share", new
            {
                url = postUrl,
                text = shareText,
                title = $"Post by @{Post.UserName}"
            });
        }
        catch (Exception)
        {
            try
            {
                // Fallback to clipboard copy
                var postUrl = $"{Navigation.BaseUri}post/{Post.Id}";
                await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", postUrl);
                
                // You might want to show a toast notification here
                // Toast.ShowSuccess("Link copied to clipboard!");
            }
            catch (Exception)
            {
                // Silently handle if both methods fail
            }
        }
    }
}