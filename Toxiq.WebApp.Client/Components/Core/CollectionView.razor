@using Microsoft.AspNetCore.Components.Web.Virtualization
@typeparam TItem
@inherits ComponentBase

<div class="collection-view @CssClass">
    @if (Items?.Any() == true)
    {
        <Virtualize ItemsProvider="@ItemsProvider"
                    Context="item"
                    ItemSize="@ItemHeight"
                    OverscanCount="@BufferSize">
            <ItemContent>
                <div class="collection-item">
                    @ItemTemplate(item)
                </div>
            </ItemContent>
            <Placeholder>
                <div class="collection-item-placeholder" style="height: @(ItemHeight)px;">
                    @if (PlaceholderTemplate != null)
                    {
                        @PlaceholderTemplate
                    }
                    else
                    {
                        <div class="skeleton-loading" style="height: @(ItemHeight)px;"></div>
                    }
                </div>
            </Placeholder>
        </Virtualize>
    }
    else if (!IsLoading)
    {
        <!-- Empty state -->
        <div class="empty-state">
            @if (EmptyTemplate != null)
            {
                @EmptyTemplate
            }
            else
            {
                <div class="empty-content">
                    <p>@EmptyMessage</p>
                </div>
            }
        </div>
    }
    else
    {
        <!-- Initial loading -->
        <div class="initial-loading">
            <div class="loading-spinner"></div>
            <span>Loading content...</span>
        </div>
    }
</div>

@code {
    // Essential parameters
    [Parameter] public IEnumerable<TItem>? Items { get; set; }
    [Parameter] public RenderFragment<TItem> ItemTemplate { get; set; } = default!;

    // Events
    [Parameter] public EventCallback OnLoadMore { get; set; }
    [Parameter] public EventCallback OnRefresh { get; set; }
    [Parameter] public EventCallback<TItem> OnItemClick { get; set; }

    // Settings
    [Parameter] public int ItemHeight { get; set; } = 200;
    [Parameter] public int BufferSize { get; set; } = 5;
    [Parameter] public bool HasMoreItems { get; set; } = true;
    [Parameter] public bool IsLoading { get; set; } = false;

    // UI
    [Parameter] public string EmptyMessage { get; set; } = "No items to display";
    [Parameter] public RenderFragment? EmptyTemplate { get; set; }
    [Parameter] public RenderFragment? PlaceholderTemplate { get; set; }
    [Parameter] public string CssClass { get; set; } = "";

    // Track when we've triggered load more to prevent duplicate calls
    private bool hasTriggeredLoadMore = false;
    private int lastItemCount = 0;

    protected override void OnParametersSet()
    {
        // Reset load more trigger when items change (new data loaded)
        var currentItemCount = Items?.Count() ?? 0;
        if (currentItemCount != lastItemCount)
        {
            hasTriggeredLoadMore = false;
            lastItemCount = currentItemCount;
        }
    }

    // Virtualization provider with load more detection
    private async ValueTask<ItemsProviderResult<TItem>> ItemsProvider(ItemsProviderRequest request)
    {
        if (Items == null)
            return new ItemsProviderResult<TItem>(Array.Empty<TItem>(), 0);

        var items = Items.ToList();
        var totalCount = items.Count;

        // Check if we're approaching the end and need to load more
        var endIndex = request.StartIndex + request.Count;
        var shouldLoadMore = endIndex >= totalCount - BufferSize &&
                           HasMoreItems &&
                           !IsLoading &&
                           !hasTriggeredLoadMore &&
                           OnLoadMore.HasDelegate &&
                           totalCount > 0; // Don't trigger on initial empty load

        if (shouldLoadMore)
        {
            hasTriggeredLoadMore = true;

            // Trigger load more in background
            _ = Task.Run(async () =>
            {
                await InvokeAsync(async () =>
                {
                    await OnLoadMore.InvokeAsync();
                });
            });
        }

        // Return the requested items
        var startIndex = Math.Max(0, Math.Min(request.StartIndex, totalCount));
        var count = Math.Min(request.Count, totalCount - startIndex);
        var requestedItems = items.Skip(startIndex).Take(count);

        return new ItemsProviderResult<TItem>(requestedItems, totalCount);
    }

    // Public method to manually refresh
    public async Task RefreshAsync()
    {
        if (OnRefresh.HasDelegate)
        {
            hasTriggeredLoadMore = false; // Reset on refresh
            await OnRefresh.InvokeAsync();
        }
    }

    // Public method to manually load more
    public async Task LoadMoreAsync()
    {
        if (OnLoadMore.HasDelegate && !IsLoading && HasMoreItems)
        {
            await OnLoadMore.InvokeAsync();
        }
    }
}