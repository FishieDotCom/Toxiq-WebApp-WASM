@using Microsoft.AspNetCore.Components.Web.Virtualization
@typeparam TItem
@inherits ComponentBase
@implements IDisposable

<div class="collection-view @CssClass">
    @if (VirtualizationEnabled && Items?.Any() == true)
    {
        <!-- Use Blazor's built-in Virtualize component -->
        <Virtualize ItemsProvider="@ItemsProvider"
                    Context="item"
                    ItemSize="@ItemHeight"
                    OverscanCount="@BufferSize">
            <ItemContent>
                <div class="collection-item" @onclick="() => HandleItemClick(item)">
                    @ItemTemplate(item)
                </div>
            </ItemContent>
            <Placeholder>
                <div class="collection-item-placeholder" style="height: @(ItemHeight)px;">
                    @if (PlaceholderTemplate != null)
                    {
                        @PlaceholderTemplate
                    }
                    else
                    {
                        <div class="skeleton-loading" style="height: @(ItemHeight)px;"></div>
                    }
                </div>
            </Placeholder>
        </Virtualize>
    }
    else if (Items?.Any() == true)
    {

    }
    else if (!IsLoading)
    {
        <!-- Empty state -->
        <div class="empty-state">
            @if (EmptyTemplate != null)
            {
                @EmptyTemplate
            }
            else
            {
                <div class="empty-content">
                    <p>@EmptyMessage</p>
                </div>
            }
        </div>
    }
    else
    {
        <!-- Initial loading -->
        <div class="initial-loading">
            <div class="loading-spinner"></div>
            <span>Loading content...</span>
        </div>
    }
</div>

@code {
    // Essential parameters only
    [Parameter] public IEnumerable<TItem>? Items { get; set; }
    [Parameter] public RenderFragment<TItem> ItemTemplate { get; set; } = default!;

    // Events
    [Parameter] public EventCallback OnLoadMore { get; set; }
    [Parameter] public EventCallback OnRefresh { get; set; }
    [Parameter] public EventCallback<TItem> OnItemClick { get; set; }

    // Basic settings
    [Parameter] public bool VirtualizationEnabled { get; set; } = false; // Default to false for simplicity
    [Parameter] public int ItemHeight { get; set; } = 100;
    [Parameter] public int BufferSize { get; set; } = 5;
    [Parameter] public bool HasMoreItems { get; set; } = true;
    [Parameter] public bool IsLoading { get; set; } = false;

    // UI
    [Parameter] public string EmptyMessage { get; set; } = "No items to display";
    [Parameter] public RenderFragment? EmptyTemplate { get; set; }
    [Parameter] public RenderFragment? PlaceholderTemplate { get; set; }
    [Parameter] public string CssClass { get; set; } = "";
    [Parameter] public string ContainerHeight { get; set; } = "100%";

    // Simple fields
    private ElementReference loadMoreRef;
    private bool isScrollNearBottom = false;

    // Virtualization provider
    private async ValueTask<ItemsProviderResult<TItem>> ItemsProvider(ItemsProviderRequest request)
    {
        if (Items == null) return new ItemsProviderResult<TItem>(Array.Empty<TItem>(), 0);

        var items = Items.ToList();
        var totalCount = items.Count;

        var startIndex = Math.Max(0, Math.Min(request.StartIndex, totalCount));
        var count = Math.Min(request.Count, totalCount - startIndex);
        var requestedItems = items.Skip(startIndex).Take(count);

        return new ItemsProviderResult<TItem>(requestedItems, totalCount);
    }

    // Simple scroll handler
    // private async Task OnScroll(UIEventArgs e)
    // {
    //     // Simple intersection check - trigger load more when near bottom
    //     if (HasMoreItems && !IsLoading && OnLoadMore.HasDelegate)
    //     {
    //         await InvokeAsync(async () =>
    //         {
    //             await TriggerLoadMore();
    //         });
    //     }
    // }

    private async Task TriggerLoadMore()
    {
        if (OnLoadMore.HasDelegate && !IsLoading)
        {
            await OnLoadMore.InvokeAsync();
        }
    }

    private async Task HandleItemClick(TItem item)
    {
        if (OnItemClick.HasDelegate)
        {
            await OnItemClick.InvokeAsync(item);
        }
    }

    // Simple refresh method
    public async Task RefreshAsync()
    {
        if (OnRefresh.HasDelegate)
        {
            await OnRefresh.InvokeAsync();
        }
    }

    public void Dispose()
    {
        // Nothing to dispose in this minimal version
    }
}