@typeparam TItem
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<div class="infinite-scroll-view @CssClass">
    @if (Items?.Any() == true)
    {
        @foreach (var item in Items)
        {
            @ItemTemplate(item)
        }
    }
    else if (!IsLoading && !HasMoreItems)
    {
        @if (EmptyTemplate != null)
        {
            @EmptyTemplate
        }
        else
        {
            <div class="empty-state">
                <p>@EmptyMessage</p>
            </div>
        }
    }

    @if (IsLoading)
    {
        @if (LoadingTemplate != null)
        {
            @LoadingTemplate
        }
        else
        {
            <div class="loading-section">
                <div class="loading-spinner"></div>
                <span>Loading...</span>
            </div>
        }
    }

    @if (HasMoreItems && !IsLoading)
    {
        <div @ref="_lastItemIndicator" style="height: 1px; flex-shrink: 0;"></div>
    }
    else if (!HasMoreItems && Items?.Any() == true)
    {
        <div class="end-message">
            <p>You've reached the end!</p>
        </div>
    }
</div>

@code {
    // Parameters - component just displays, parent controls logic
    [Parameter] public IEnumerable<TItem>? Items { get; set; }
    [Parameter] public RenderFragment<TItem> ItemTemplate { get; set; } = default!;
    [Parameter] public RenderFragment? LoadingTemplate { get; set; }
    [Parameter] public RenderFragment? EmptyTemplate { get; set; }
    [Parameter] public string EmptyMessage { get; set; } = "No items to display";
    [Parameter] public string CssClass { get; set; } = "";

    // State controlled by parent
    [Parameter] public bool IsLoading { get; set; } = false;
    [Parameter] public bool HasMoreItems { get; set; } = true;

    // Event for parent to handle
    [Parameter] public EventCallback OnLoadMore { get; set; }

    // Internal state
    private ElementReference _lastItemIndicator;
    private IJSObjectReference? _module;
    private IJSObjectReference? _instance;
    private DotNetObjectReference<InfiniteScrollView<TItem>>? _componentReference;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && HasMoreItems)
        {
            await InitializeIntersectionObserver();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        // Re-initialize observer when HasMoreItems changes
        if (_instance != null && HasMoreItems)
        {
            await _instance.InvokeVoidAsync("onNewItems");
        }
    }

    private async Task InitializeIntersectionObserver()
    {
        try
        {
            _module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/infinite-scroll.js");
            _componentReference = DotNetObjectReference.Create(this);
            _instance = await _module.InvokeAsync<IJSObjectReference>("initialize", _lastItemIndicator, _componentReference);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing intersection observer: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task OnIntersection()
    {
        // Just notify parent - don't handle loading logic here
        if (HasMoreItems && !IsLoading && OnLoadMore.HasDelegate)
        {
            Console.WriteLine("InfiniteScrollView: Intersection detected, notifying parent");
            await OnLoadMore.InvokeAsync();
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_instance != null)
        {
            await _instance.InvokeVoidAsync("dispose");
            await _instance.DisposeAsync();
        }

        if (_module != null)
        {
            await _module.DisposeAsync();
        }

        _componentReference?.Dispose();
    }
}