@using Toxiq.WebApp.Client.Helper
@typeparam TItem
@implements IAsyncDisposable
@inject IJSRuntime JSRuntime

<div class="infinite-scroll-view @CssClass">
    @if (_items.Any())
    {
        @foreach (var item in _items)
        {
            @ItemTemplate(item)
        }
    }
    else if (!_loading && _enumerationCompleted)
    {
        @if (EmptyTemplate != null)
        {
            @EmptyTemplate
        }
        else
        {
            <div class="empty-state">
                <p>@EmptyMessage</p>
            </div>
        }
    }

    @if (_loading)
    {
        @if (LoadingTemplate != null)
        {
            @LoadingTemplate
        }
        else
        {
            <div class="loading-section">
                <LoadingSpinner />
                <span>Loading...</span>
            </div>
        }
    }

    @if (!_enumerationCompleted && !_loading)
    {
        <div @ref="_lastItemIndicator" style="height: 1px; flex-shrink: 0;"></div>
    }
</div>

@code {
    // Parameters
    [Parameter] public ItemsProviderDelegate<TItem>? ItemsProvider { get; set; }
    [Parameter] public RenderFragment<TItem> ItemTemplate { get; set; } = default!;
    [Parameter] public RenderFragment? LoadingTemplate { get; set; }
    [Parameter] public RenderFragment? EmptyTemplate { get; set; }
    [Parameter] public string EmptyMessage { get; set; } = "No items to display";
    [Parameter] public string CssClass { get; set; } = "";

    // State
    private List<TItem> _items = new();
    private bool _loading = false;
    private bool _enumerationCompleted = false;
    private ElementReference _lastItemIndicator;

    // JavaScript interop
    private IJSObjectReference? _module;
    private IJSObjectReference? _instance;
    private DotNetObjectReference<InfiniteScrollView<TItem>>? _componentReference;

    public delegate ValueTask<IEnumerable<TItem>> ItemsProviderDelegate<T>(InfiniteScrollRequest request);

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await LoadInitialItems();

            // Initialize JavaScript intersection observer
            _module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./js/infinite-scroll.js");
            _componentReference = DotNetObjectReference.Create(this);
            _instance = await _module.InvokeAsync<IJSObjectReference>("initialize", _lastItemIndicator, _componentReference);
        }
    }

    private async Task LoadInitialItems()
    {
        if (ItemsProvider == null) return;

        _loading = true;
        StateHasChanged();

        try
        {
            var request = new InfiniteScrollRequest(0, 20);
            var newItems = await ItemsProvider(request);
            _items.AddRange(newItems);

            if (!newItems.Any())
            {
                _enumerationCompleted = true;
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading initial items: {ex.Message}");
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    [JSInvokable]
    public async Task LoadMoreItems()
    {
        if (_loading || _enumerationCompleted || ItemsProvider == null)
            return;

        _loading = true;
        StateHasChanged();

        try
        {
            var request = new InfiniteScrollRequest(_items.Count, 20);
            var newItems = await ItemsProvider(request);

            var previousCount = _items.Count;
            _items.AddRange(newItems);

            if (_items.Count == previousCount || !newItems.Any())
            {
                _enumerationCompleted = true;
            }
            else if (_instance != null)
            {
                // Re-observe the sentinel element for next batch
                await _instance.InvokeVoidAsync("onNewItems");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error loading more items: {ex.Message}");
        }
        finally
        {
            _loading = false;
            StateHasChanged();
        }
    }

    // Public method to refresh data
    public async Task RefreshAsync()
    {
        _items.Clear();
        _enumerationCompleted = false;
        await LoadInitialItems();

        if (_instance != null)
        {
            await _instance.InvokeVoidAsync("onNewItems");
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_instance != null)
        {
            await _instance.InvokeVoidAsync("dispose");
            await _instance.DisposeAsync();
        }

        if (_module != null)
        {
            await _module.DisposeAsync();
        }

        _componentReference?.Dispose();
    }

 
}
